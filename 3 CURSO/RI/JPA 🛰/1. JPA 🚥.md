# 13 Octubre 2022 🏖
---
- Ahora vamos a utilizar el modelo de dominio, que hace que el esfuerzo de implementación sea mucho más estable
- **Mapeadores Objeto-Relacional**
	- Permite la persistencia y es transparente a objetos en BBDD relacionales
	- Mínima intrusividad en el código
	- Soporta concurrencia
	- Se programa pensando en objetos
	- No es necesario escribir JDBC

Diferencias estructurales y dinámicas entre modelo relacional y modelo OO:
- **Estructurales**
	- **Granularidad**: hay varios tipos de clases (entidades y value types)
	- **Identidad**: en java el == o el equals o el hashCode, en BDD relacional la clave primaria define la identidad
	- **Subtipado**
	- **Asociaciones**: *navegabilidad* (unidireccional o bidireccional) y *cardinalidad* (uno a uno, uno a muchos, muchos a muchos)
- **Dinámicas**: generan pérdidas de eficiencia en tiempo de ejecución
	- **Navegación**: *eager loading* (se carga un objeto y sus asociados, puede sobrecargar la memoria con objetos no necesarios) y *lazy loading* (se carga sólo lo necesario, pero genera el problema de las n+1 consultas)
	- **Cacheado**: optimiza el rendimiento al reducir el trasiedo de la BBDD y permite hacer optimizaciones (write-behind delayed o batch load/update)
	- **Concurrencia**: si hay varios hilos de ejecución se crea una caché por hilo y la BDD gestiona las transacciones

---
# 20 Octubre 2022 💡
## Gestión de objetos persistentes en JPA

Ciclo de vida de un objeto:
- new
- en memoria
- a la basura

- Con un **mapeador** entrando en juego, el estado de memoria se divide en tres estados diferentes:
	- **transient**: cuando no tengo el mapeador y hago un new(), el objeto está únicamente en memoria (no existe en la bbdd)
	- **persistent**: existe en la base de datos, y está vigilado por el mapeador (si se hacen modificaciones de escritura, se sobreescriben en la base de datos). Vamos de transient a persistent a través del método *persist()*. Es un estado gestionado
	- **detached**: un objeto que sigue en memoria despueés de la sesión. Existe en Java y en la BBDD
- El merge crea un nuevo objeto  y lo devuelve

## Mapeo de clases
- La información necesaria para persistir objetos se añade en forma de metadatos (anotaciones en el código)


---